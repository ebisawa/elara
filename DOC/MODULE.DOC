
・モジュールについて

	Elara が実行できるモジュールには

	・dlm タイプ - 実行型モジュール
	・ddm タイプ - デバイスドライバ

	の２種類あります。

	モジュールは基本的に C言語で開発します。

	tiny モデルで DS != SS を想定したコードを作成できるコンパイラが
	必要です。Borland C++ 3.1 で作成できることを確認しています。


・ライブラリ

	C言語でモジュールを作成するためのライブラリが用意されています。

	klib.h - カーネルアクセスライブラリ
	mlib.h - 各種ユーティリティ

	それぞれの詳細については klib.doc, mlib.doc を参照してください。


・モジュール作成手順

	(1) まずコンパイルするソールファイルを用意します。
	(2) コンパイルします。
	(3) リンクします。
	(4) mkdm で EXE -> モジュール変換を行います。


	注意点

	(1) DS が SS と一致しないので、ポインタの扱い(nearかfarか)
	    に注意する必要があります。ほとんどが far になるはずです。

	(2) コンパイルは tiny モデルで DS != SS を想定したコードを作成する
	    ようにしなくてはなりません。

	    Elara はスタックを CODE, DATA とは違った場所に確保します。

	    tiny モデル以外でコンパイルするとリロケーションをしなくては
	    ならないことがありますが、その場合にはモジュールを作成できません。

	(3) C の標準ライブラリは一切使用できません。
	    また、スタートアップは専用のものを使用します(ddm0.obj, dlm0.obj)。

	    long の掛け算・割り算や、ローカル変数を文字列で初期化する等で、
	    コンパイラが内部的にライブラリを使用することがあります。

	    このようなものは使用できませんので、自作のものを使用するか、
	    あきらめるかしてください。

	(4) 作成する EXE ファイルは、リロケーション数が 0 でなければ
	    なりません。リロケーションは、farポインタのテーブル等で
	    発生します。


・モジュール作成上の注意

	モジュールサイズ(未初期化データ領域も含む)は、64Kバイト以内に
	制限されます。

	実行時には、コード, データ領域は共有されます。
	したがって、グローバル変数は複数のプロセスで共有されますので
	注意してください。

	スタックは、コード, データとは別のセグメントに確保されます。
	よって、DS != SS であることに注意してください。
	ほとんどの場合、ポインタは far でなければならないはずです。

	プロセス切り替えはシステムコールを行うたびに発生します。
	長期間システムコールを行わないと他のプロセスが止まります。


	あとはデッドロックに注意してください。

	DOSは通常、オープンできるファイル数は１プロセス当たり
	最大で 20 までです。Elara Kernel はこれを拡張していませんので、
	限界に達するとファイルオープン要求がブロックされます。

	なので、長期間ファイルをオープンしたままにしておくと、
	多数のプロセスが動いている場合はずっとブロックされたままに
	なるプロセスがでてくるかもしれません。

	メモリが足りない場合も自動的にブロックされますので、
	注意が必要です。メモリが足りなくなるとカーネルに必要なメモリも
	確保できなくなりますから、期待した動作が行えない可能性があります。
	基本的にメモリは余裕を持って空けておくようにしてください。


	スタートアップ(dlm0.obj は最初に関数 main を near call します。
	引数・戻り値はありません。


・デバイスドライバ作成上の注意

	デバイスドライバはカーネル内から直接 far call されます。
	デバドラからのシステムコールはカーネル再突入を引き起こします。
	カーネルは再突入可能ですが、いくつかの制限があります。

	・DS がカーネル内を指したままなので、DS を使用する場合は
	  自前で保存・設定を行う必要がある。

	・デバドラから復帰するまでプロセス切り替えは発生しない。
	  そのため、デバイスドライバからは速やかに復帰する必要がある。

	  relcpu() を実行してもプロセスは切り替えられないし、
	  exec(), spawn() を実行してもすぐに戻ってくる。

	  これらで起動されたプロセスは、デバドラから復帰後に実行を開始する。


・デバイスドライバの作成方法

	デバイスドライバには、init, term, open, close, read, write, ioctl
	の７つのエントリが存在することが求められます。

	int far dev_init(char far *argv)

		デバイスドライバ組み込み時に呼ばれます。
		argv にはオプション文字列が渡されます。

		0 以外を返すと失敗にすることができます。

	int far dev_term(void)

		デバイスドライバ解放時に呼ばれます。

		0 以外を返すと失敗にすることができます。

	void far * far dev_open(char far *name)

		デバイスをオープンする時に呼ばれます。
		戻り値として、各デバイスを識別できる値を返します。

	void far dev_close(device_struct far *p)

		デバイスをクローズする時に呼ばれます。

	unsigned far dev_read(char far *buf, unsigned size, void far *p)

		デバイスより入力を行う時に呼ばれます。
		buf が指す領域へ size バイト入力します。
		p には open が返したポインタが渡されます。

		実際に入力したサイズを返します。

	unsigned far dev_write(char far *buf, unsigned size, void far *p)

		デバイスより出力を行う時に呼ばれます。
		buf が指す領域から size バイト出力します。
		p には open が返したポインタが渡されます。

		実際に出力したサイズを返します。

	int far dev_ioctl(char far *devname, unsigned command, void far *param)

		デバイスに何等かのメッセージを送りたい時に呼ばれます。
		注意しなくてはいけないのは、オープンされていないデバイスにも
		ioctl 要求が発生する可能性があることです。


・Elara 起動手順

	Elara Kernel は起動されると各種初期化を行った後、
	init.dlm というファイルを実行します。

	init.dlm がどのような動作をするかについてはモジュール作成者に
	まかされています。

